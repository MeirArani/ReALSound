% Preamble
% ---
\documentclass{report}
% Packages
% ---
\usepackage{amsmath} % Advanced math typesetting
\usepackage[utf8]{inputenc} % Unicode support (Umlauts etc.)
\usepackage{hyperref} % Add a link to your document
\usepackage{graphicx} % Add pictures to your document
\usepackage{listings} % Source code formatting and highlighting
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{xspace}

\newcommand{\rs}{ReAL Sound\xspace}
\newcommand{\rsfull}{\textbf{Re}-usable \textbf{A}udification \textbf{L}ibrary\xspace}
\newcommand{\plan}{\textbf{Planning}\xspace}
\newcommand{\train}{\textbf{Training}\xspace}
\newcommand{\design}{\textbf{Design}\xspace}
\newcommand{\exec}{\textbf{Execution}\xspace}
\newcommand{\state}[1]{\textbf{#1}}

% ---
%
\begin{document}

%%% TITLE

\author{Meir Arani \\ Kyushu University \\ Graduate School of Design} % The authors name
\title{ReAL Sound: Outline of a Reusable Audification Library to Improve Game Accessibility for the Visually Impaired} 
\date{\today{}} 
\maketitle{} 

%%% ABSTRACT

\begin{abstract}
    In a world of ever-increasing software complexity, there has been a growing demand for interoperable, reusable technologies that function in many problem domains. This is especially true in the world of game development, where tools, structures, and architectures often change from title to title. At the same time, the specificity of software user needs has also grown immensely, bringing an increased demand for advanced accessibility tools with it. To address these trends, we propose ReAL Sound: the ReUsable Audification Library, which abstracts the creation of visual accessibility technology for impaired persons in the realm of game design using computer vision and machine learning techniques.  
\end{abstract}

\newpage{} % Pagebreak

%%% TABLE OF CONTENTS

\tableofcontents{} % Generates table of contents from sections and subsections
\newpage{} % Pagebreak


%%% INTRODUCTION

\chapter{Introduction}
\section{Recent Advances in Software Development}
\section{Recent User Experience Trends}
\section{Games and Accessibility}


%%% LITERATURE REVIEW
\chapter{Literature Review} 
\section{Computer Vision}
\section{AI \& Machine Learning}
\section{Audification}
\subsection{Spatial Audio}
\section{Games}
\subsection{Games and Accessibility}
\subsection{Games and Audification}
\subsection{Games and Computer Vision}

%%% PROPOSAL

\chapter{ReAL Sound}
\paragraph{Introduction}
In this chapter, I propose and outline the \textbf{\emph{\rs}} system: a \rsfull that abstracts the design of accessibility features for the visually impaired via the use of computer vision, spatial audio, and audification techniques.

\section{Proposal} 
\paragraph{Introduction} 

In this section, I propose \rs and justify its novelty and utility based on the literature review performed in the previous chapter.

\subsubsection{\emph{What is \rs?}}
\rs (\rsfull) is a software framework concept that generalizes the creation of visual accessibility features for games. Using computer vision techniques and modern spatial audio technology, \rs aims to abstract the process of moment-to-moment analysis of a game's state as well as the generation of 3D spatial audio objects. Through this abstraction, implementors of /rs (as distinguished from \emph{users} of \rs---the visually impaired persons benefitting from the features) can sidestep many of the language, platform, and architecture specific headaches involved in the creation of game accessibility features, especially in the case of after-market games. 

\rs achieves this generalization by abstracting the process into a few core steps for any given target game:

\begin{description}
    \item [Planning] The creation of simple 'rules' and 'definitions' which accurately describe the game.
    \item [Training] The act of preparing computer vision techniques based on the \textbf{Planning} stage to analyze the game's current state data.
    \item [Design] The creation of simple 'rules' and 'definitions' for translating the data analyzed in the \textbf{Training} phase into spatial audio objects. 
    \item [Execution] The real-time marriage of the previous stages. Uses a computer vision model \textbf{trained} on the \textbf{planned} rules which translates the game's real-time visual data into spatial audio objects as \textbf{designed} by the implementor.    
\end{description}

With \rs, a implementor with only a moderate amount of technical knowledge  could feasibly add accessibility features to any target game---all with zero knowledge of the game's underlying source code or architecture.


\subsubsection{\emph{Why is \rs?}}
As discussed in the previous chapter, there is a well-established and ever-growing need for software interoperability and platform agnostic support, as well as a growing demand for improved software accessibility. Implementors of game accessibility features already face numerous game-specific challenges in the design process---as each game's bespoke nature demands equally unique accessibility design. The added barriers of specific architecture, engine, and language implementation have especially stymied the development of accessibility features in the gaming industry---where many development tools target a single architecture or operating system, are company specific, and are often used on a per-game basis. 

\rs significantly streamlines these problems through abstraction---significantly simplifying this troubled implementation process. As a consequence, greater flexibility and more time are handed to feature designers---who are now better quipped to craft higher quality features at a faster clip.

Moreover, the generalization process requires zero knowledge of the game's actual codebase, meaning games can be modified in the after-market by dedicated enthusiasts. As a consequence, the fan-driven movement of retrofitting of older titles with modern accessibility features becomes easier---allowing visually impaired persons access to a wealth of classic titles while costing modern developers zero resources. This is becoming especially crucial in modern times, as some estimates show that over 85\% of games are functionally abandoned---with no publisher or developer entity maintaining ownership \cite{Lewin_2023}. This fact effectively renders the vast majority of published games, \emph{'abandonware'} with little hope of official improvements by original developers \cite{Costikyan_2000}.

\subsubsection{\emph{How is \rs?}}
\rs is made possible through modern machine learning, computer vision, and spatial audio technologies. Using the latest computer vision techniques through libraries like OpenCV\cite{opencv_library}, even novice developers can implement object detection algorithms---which analyze visual input and return semantic information about the its contents---with ease. 

\paragraph{The Modern AI Boom}

On top of this, the recent 'boom' in AI technologies\cite{Knight_2023}\cite{Meredith_2023} has brought an equally intense focus to the development, improvement, and democratization of AI tools and systems\cite{Brynjolfsson_McAfee_2017}\cite{Heikkil√§_2022}. Ecosystems like \emph{HuggingFace}\cite{Wiggers_2022} and projects like Google's \emph{TensorFlow}\cite{tensorflow2015-whitepaper} have dramatically changed the landscape of AI technology development---trivializing many tasks considered inaccessible to the common developer just a few years ago.

\subparagraph{Agnostic Vision Requirements}

Considering the ever-changing state of modern AI and computer vision technology, \rs does not specifically call for any one particular solution for its \textbf{Training} or \textbf{Execution} stages. Instead, \rs only requires the \emph{successful} real-time identification of in-game objects \textit{as defined by the implementor}. The means by which this goal is accomplished is left up to the implementor, and may be achieved by any available means. 

Consequently, \rs does not technically demand the usage of AI \emph{at all.} Many well-proven pre-AI techniques---such as \emph{template matching}\cite{Brunelli2009-gh} and \emph{corner detection}\cite{Hildreth1980}---have proven to be successful in many simple use-cases. I will demonstrate this in a later chapter, creating one  implementation of \rs using the original corner detection algorithm---the \emph{Harris corner detector}\cite{Harris}, originally developed in 1986. 

\paragraph{Spatial Audio}
Running alongside the AI boom has been a comparably smaller (yet not insignificant) boom of 3D and spatial audio technologies. As discussed in the previous chapter, many advances have been made in sonification, audification, and spatial audio techniques in recent years. This trend has given end-users an abundance of choice for low-cost, high quality audio playback devices with native spatial audio support--from in-ear monitors like the the Apple \emph{AirPods}\cite{ApplePods} to even computer display monitors from major manufacturers like Dell\cite{Campbell_2025}. Future patents promise even greater advancements through advanced techniques like automatic HRTF adjustments specific to the user's unique physiology\cite{Antti2024}.


Many new software development libraries been developed to address this boom in consumer demand. Fan driven efforts like the \emph{Spatial\_Audio\_Framework}\cite{McCormack2024} as well as company-produced projects such as Valve Software's Steam Audio\cite{Valve} have seen popular adoption. Legacy libraries with widespread adoption, such as the quarter-century old \emph{Qt} application development framework\cite{QTProgramming}, have also introduced support for modern spatial audio technologies in recent versions\cite{QTSpatial}. The implementations of \rs presented later in later sections utilize Qt as a backend framework---although numerous other libraries feature equivalent functionality. 

\paragraph{Conclusion}
In this section, I proposed \rs and provided justifications for its utility and novelty by considering contemporary technology innovations and emergent user trends. 





\section{Concepts}
\paragraph{Introduction} 
In this section, I explain in detail the theoretical concepts which underpin \rs. I later use these concepts to rigidly define the system's core structure. To begin, I use formal math notation to construct a semi-formal definition of a 'video game.' I then explore this definition through the lens of automata theory. Following this, I use the construct to abstract methods of interpreting a game via visual analysis. 


\subsection{Anatomy of a Game}
\subsubsection{Introduction}
Here, I construct a semi-rigid abstraction of video games using formal notation. Later, I will use these constructs to more clearly explore related concepts.


\subsubsection{Game}
A Game, termed $M$ (for \emph{meta}), can be conceived as the combination of three sets: a collection of meta attributes $A$, a series of in-game states $G$, and a group of entities $I$:

$$
M = \{A, G, I\}
$$

\paragraph{Meta Attributes}
The game's meta-attributes $M_A$ can be imagined as data that is preserved over an entire game session. This data can persist between state transitions and usually describes overarching information such as current playtime or the currently active game level. 

\subsubsection{Game State}
Each state, $G_S$ (referred to interchangeably as \textit{game state} hereafter) is comprised of four components---internal state-attributes $A$, internal state-logic $L$, as well as conditions $C$ for inter-state transitions $T$.

$$
G_S = \{ A, L, C, T \}
$$

\paragraph{State Attributes}
A state's attributes $A$ act similarly to the game's overarching meta attributes $M_A$, but on a per-state context. These attributes may store information such as the current time spent within the state or other data describing the state in specific. State data is lost upon transitioning to a different state.

\paragraph{Internal Logic}
The state's internal logic $L$ defines all the behaviors and activities that are carried out \textit{within} the state. For example, a racing game may contain a \textbf{start} state---which contains logic for playing a special sound effect when the race is started, or routines to visually display the text \textit{'START!'} on-screen. 

In abstract, $L$ can be imagined as a series of conditional requirements ('rules') $L_C$ that yield specific game actions ('responses') $L_A$:

$$L: L_C \longrightarrow L_A$$


\paragraph{Conditions}
A state also contains conditional rules defining when to exit the state and transition to different state. $C$ defines these rules as a set of boolean statements---which evaluate to either \texttt{true} or \texttt{false}.
Take, for example, a sports game which transitions from a \textbf{match} state to a \textbf{finish} state after ten points are scored in the match. Imagine that the current match score is stored as an integer value through the state attribute $S$: 

$$
S: [0, 10],  S \in G_A
$$

Then there is a condition within $C$, lets call it $C_S$, which might look like this:

$$
C_S = S\geq10 
$$

When $C_S$ evaluates to true (i.e., when the match score has reached ten points), the state will transition transition to the \textbf{finish} state.

\paragraph{Transitions}
The transition function $T$ defines the mapping of "where" to or "how" to transition to a different state after a condition in $C$ has evaluated to \texttt{true}. In essence, $T$ maps a conditional statement $C_S$ to the next game state $G_N$ to transition to:

$$
T: C_S \longrightarrow G_N
$$

This function can be generalized by instead taking a specific state $G_S$ and a generic condition $C$ as input:

$$
T: G_S \times C \longrightarrow G_N
$$

\subsubsection{Entities}
Entities $I$ are the objects which constitute a game's internal structure---the 'actors' of the game. An entity can be anything contained within a game, such as the player, enemies, items, level construction, etc.  Usually, an entity's behavior can be described using verbs---in either an active (\emph{Mario jumps on the platform}) or passive (\emph{The platform was jumped on by Mario}) sense.

Each entity has attributes $A$ as well a collection of states $E$:

$$I = \{A, E\}$$

\paragraph{Entity Attributes}
Similar to the previous definitions, entity attributes describe entity-specific attributes. For example, an entity's location point $P$ in a 2D game's world space might be modeled as:

$$P = \{(x,y): x,y \in \mathbf{R} ^2\}$$ 

Similar information, like a enemy's current health, an item's purchase price, or a bomb's damage radius are also considered Entity attributes. 

\paragraph{Entity States}
An entity state, then, describes an entity's different states of being. A player entity might be able to \textbf{jump}, while a spell entity might be \textbf{cast} or an enemy entity might be \textbf{killed}, to name a few examples. 

Some examples may seem unintuitive, but still work within this framework. A game's menu system, for instance can also be considered an entity. In this case, the act of clicking on the menu---triggering some sort of effect, can be modeled as a \textbf{clicked} state with its own internal logic and goals. 

As you might guess, a entity state looks similar to a game state, with its own internal logic $L$, a series of transition conditionals $C$, and transition mappings $T$:

$$E = \{L, C, T\}$$

One example of an entity state is \textbf{jumping}, which may transition from \textbf{idle} or \textbf{walking} or \textbf{running}. When transitioned to, the \textbf{jumping} state might, according to $L$, play a jumping sound effect. When a condition in $C$ is satisfied (the jumping entity finally touches the ground again, or perhaps falls into a pit and dies), then the transition function $T$ moves to the next state $E_N$:

$$T(C) \longrightarrow E_N$$

\subsubsection{Summary}
To summarize, a game $M$ can be conceptualized as:

\begin{enumerate}
    \item A collection of attributions ($A$), which describe aspects of the game's overarching meta-state.
    \item A set of game states ($G$), which each contain internal game-logic ($L$), state-specific attributes ($A$), as well as rules for when to transition to another state ($C$) and exactly which state to transition to ($T$).   
    \item A set of entities ($I$) which serve as the game's passive and active subjects, each having their own set of attributes ($A$) and states ($E$). Each state compasses the same qualities of a state enumerated above ($A$, $L$, $C$, and $T$).   
\end{enumerate}

$$
M = \{A, G, I\}
$$

$$
G_S = \{ A, L, C, T \}
$$

$$I = \{A, E\}$$

$$E = \{L, C, T\}$$


\subsubsection{Conclusion}
Here, I have provided a general outline of games in formal notation. I do not guarantee nor contend that these structures form a complete closure over the entire concept of video games---whose definition is still fiercely debated to this day\cite{Knoop_2021}---but these structures will serve as a useful framework for our following definitions and concepts.

\subsection{State Models}

\subsubsection{Introduction} 
In this section, I briefly review automata theory theory. Through concepts like finite state automata, I produce the Game and Entity (GSM and ESM) state machine constructs, which I will continue to utilize in following sections.

\subsubsection{Automata Theory}
The previous section's underlying theory will likely seem familiar for those with a background in fields such at theory of computation or advanced linguistics. I am, of course, referring to the theory of \emph{automata} a core concept which underpins numerous fields--including computing and, by natural extension, interactive software such as video games. 

Automata are generally categorized into four major types as defined by the Chomsky Hierarchy---ranging from Type-0, describing the classical Turning machine, to Type-3, which describes finite state automata \cite{Chomsky1956ThreeMF}. Games, as I have described them above, can (in general) be described as a Type-3 automata---an automation of finite state and quality. 

\subsubsection{Finite State Automata}

\paragraph{Introduction and Concepts}

Carroll defines (deterministic) finite automata as the "mathematical model of a machine that accepts a particular set of words over some alphabet $\Sigma$.\cite{FSM}" He conceptualizes FSMs as "black boxes" that combine an input tape (consisting of symbols in the alpha $\Sigma$), a \emph{'read head'} which processes this input tape of symbols, and an 'acceptance light' which indicates the acceptance/rejection of an input symbol, and whose activity is governed by the read head's reaction to the given input. In essence, the machine accepts input, makes decisions for the acceptance light based upon the input, and then moves to a new position to receive another input. The machine's acceptance/rejection of a symbol, as well as the position it moves to next, is contingent on its own internal logic---some rule that dictates \emph{"If symbol X is read, turn on (if accepted) or off (if rejected) the acceptance light, and move read head to position Y."} The machine may also read a symbol which finally halts its operation.

\paragraph{Comparison with Turing Machines}

This conceptual structure bares some resemblance to a Turning machine\cite{Turing}, although there are some distinct differences. A Turning machine has an infinite amount of memory and is capable of accepting languages with recursive qualities---as the turing machine is able to 'write' to tape--modifying a symbol after reading it. A Turing machine is well known to be capable of implementing and computing any possible computing algorithm\cite{Turing_2004}. It is consequently classified as a Type-0 (also known as a "recursively enumerable" or an "unrestricted") grammar.

An FSM, by contrast, is limited in several ways. As the name implies, FSM have a \emph{finite} set of states. More importantly, the system is incapable of storing memory---lacking the 'writing' mechanism of a Turning machine\cite{FSM}. 

\paragraph{Deterministic and Non-deterministic FSAs}

The FSMs we detail here should also be distinguished as \emph{deterministic}, as opposed to \emph{non-deterministic} FSMs. Some FSMs are considered non-deterministic when their states are capable of transitioning to several possible outputs given the \emph{same input}---making their reaction to an input non-deterministic in nature\cite{NDFSA}. For our purposes, we define games as a type of deterministic FSM--where the same inputs always yield the same results. 

\paragraph{Obstacles and Limitations}
You may be wondering how the provided definition of games fit the category of FSM considering the inclusion of attributes $A$---which may persist as a game or entity transitions from state-to-state. This may appear like a kind of 'memory' on first glance, but is actually just a shorthand notation that simplifies our FSM conceptualization. In reality the proper FSM of a game has \emph{many} more states than we describe here. 

To provide some insight into this concept, imagine that for each state $G_S$, the conditions of $C$ and the transitional rules of $T$ also encode the attributes of $A$. This means that each state $G_S$ actually has numerous variations---each relating to the specific attributes of $A$ and the conditions of $C$. For example, the aforementioned sport game's \state{match} state may really have $10$ different \state{match} states, one describing each possible value of the scoring attribute $S$. If the game has just begun, the first scoring condition $C_0$ will transition the machine to $match_1$, and so on. Eventually, the final \state{match} state's $C_9$ condition will transition the FSM to the \state{finish} state.


\paragraph{Useful Adaptions}

As you can see, this more-accurate representation of FSMs is considered unproductive in many domains where FSMs remain useful concepts\cite{state}. Thankfully, numerous alternative notations have arisen to address these shortcomings. 

For example, FSMs which produce output contingent on a given input---often termed \emph{transducers}\cite{FSM}---are frequently conceptualized as \emph{Mealy machines}. The output of a Mealy machine state is also contingent on its input (\texttt{IF input(X) AND IN state(Y) THEN transition(Z)}). Later designs---such as the \emph{unified modeling language}---have extended this notation further to leverage the theoretical benefits of FSAs while avoiding their limiting notation schemes\cite{omg2011umls}. In a similar fashion, I make use of FSAs on a conceptual basis while abstracting away these notational hindrances through the usage of the attributes $A$ of each object. 

\subsubsection{Automata and Games}
It is possible to define games more clearly through their relation to FSAs using our definitions. For example we can consider a game to be a collection of two principal state machines: 
\begin{description}
    \item[Game State Machine (GSM)] The game state machine comprises the general 'flow' of a game---its levels, combat encounters, win conditions, story sequences, game-over menus, boss fights, item inventories, and any other 'macro' loop that is reasonably distinguishable within the gaming experience.
    \item[Entity State Machine (ESM)] An entity state machine comprises the general 'life' and 'activities' of a given entity---every action it can take, as well as its response to any given input. A player may run, jump, or die, while a stage platform may move or vanish.     
\end{description}

These two concepts---the GSM and ESM---prove to be crucial in the conceptualization of \rs. We will continue to analyze them in later sections using other frames of analysis.

\subsubsection{Conclusion}
In this section I reviewed numerous aspects of automata theory---namely finite state automata---in order to present the concept of the Game and Entity state machines (GSM and ESM), which will prove to be useful constructs in the total construction of \rs.


\subsubsection{Visual Analysis of a Game}

\paragraph{Introduction}
In this section, I provide a framework for analyzing a game's state information based on the game's visual output by using the constructs detailed in the previous section. With this framework, I argue in the next section that a user who is aware of the game's external logic (the 'rules' a player intuitively learns via playing the game) can wield this visual analysis in building their own state model of the game.    


\section{Structural Outline}

\subsection{Vision Layer}

\subsection{Decision Layer}

\subsection{Audification Layer}

\section{Process Outline}
In this section, I outline \rs's principal operational process---the \plan, \train, \design, \exec loop. To conclude, I consider the structure's strengths and weaknesses.        

\subsection{Design}
\subsection{Training}
\subsection{Implementation}
\subsection{Play}

\section{Demonstration: Pong}
\section{Considerations}


%%% IMPLEMENTATION

\chapter{Sample Implementation}
\section{OpenCV}
\section{Qt}

%%% EXPERIMENTS

\chapter{Experiments} 
\section{Pong Demonstration}
\subsection{Results}

%%% CONCLUSION
\chapter{Conclusions}
\section{Limitations}
\section{Future Work}

\section{Thanks}

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}

